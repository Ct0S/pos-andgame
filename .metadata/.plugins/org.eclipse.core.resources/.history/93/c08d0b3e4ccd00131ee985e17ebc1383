package com.unopar.spaceboy.character;

import java.util.Random;

import org.andengine.engine.Engine;
import org.andengine.engine.handler.physics.PhysicsHandler;
import org.andengine.entity.sprite.AnimatedSprite;
import org.andengine.opengl.texture.region.ITiledTextureRegion;

import com.unopar.spaceboy.base.XApplication;

public abstract class Enemy extends AnimatedSprite {
	private PhysicsHandler mPhysicalHandler;
	private int mSpeed;
	private Random mRandom = new Random(1);
	private float mLimiteX;
	private float mLimiteY;

	public Enemy(float pX, float pY, 
			ITiledTextureRegion textureRegion, Engine engine) {
		super(pX, pY, textureRegion, engine.getVertexBufferObjectManager());
		
		mPhysicalHandler = new PhysicsHandler(this);
		registerUpdateHandler(mPhysicalHandler);
		
		mSpeed = getDefaultSpeed();
		
		mLimiteY = XApplication.getInstance().getScreenHeight() - 
				textureRegion.getHeight();
	}
	
	public void move() {
		resetPosition(false);
	}

	private void resetPosition(boolean resetXY) {
		if(resetXY) {
			float pX = mLimiteX - getTextureRegion().getWidth();
			float pY = mRandom.nextFloat() * mLimiteY;
			
			setPosition(pX, pY);
		}
		
		float velocityX = -(mRandom.nextInt(2) + 1 * mSpeed);
		float velocityY = mRandom.nextBoolean()
				? (mRandom.nextInt(2) + 1 * mSpeed)
				: -(mRandom.nextInt(2) + 1 * mSpeed);				
		
		mPhysicalHandler.setVelocity(velocityX, velocityY);
	}
	
	@Override
	protected void onManagedUpdate(float pSecondsElapsed) {
		super.onManagedUpdate(pSecondsElapsed);
		
		if(mX + getTextureRegion().getWidth() < 0) {
			resetPosition(true);
		} else {
			if(mY < 0 || mY > mLimiteY) {
				mPhysicalHandler.setVelocityY(
						-mPhysicalHandler.getVelocityY());
			}
		}
	}

	protected abstract int getDefaultSpeed();

}
